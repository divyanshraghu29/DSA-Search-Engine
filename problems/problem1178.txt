b'F. DFStime limit per test6 secondsmemory limit per test512 megabytesinputstandard inputoutputstandard outputLet TT be a tree on nn vertices. Consider a graph G0G0, initially equal to TT. You are given a sequence of qq updates, where the ii-th update is given as a pair of two distinct integers uiui and vivi. For every ii from 11 to qq, we define the graph GiGi as follows:   If Gi?1Gi?1 contains an edge {ui,vi}{ui,vi}, then remove this edge to form GiGi.  Otherwise, add this edge to Gi?1Gi?1 to form GiGi.  Formally, Gi:=Gi?1?{{ui,vi}}Gi:=Gi?1?{{ui,vi}} where ?? denotes the set symmetric difference. Furthermore, it is guaranteed that TT is always a subgraph of GiGi. In other words, an update never removes an edge of TT.Consider a connected graph HH and run a depth-first search on it. One can see that the tree edges (i.e. the edges leading to a not yet visited vertex at the time of traversal) form a spanning tree of the graph HH. This spanning tree is not generally fixed for a particular graph?? it depends on the starting vertex, and on the order in which the neighbors of each vertex are traversed. We call vertex ww good if one can order the neighbors of each vertex in such a way that the depth-first search started from ww produces TT as the spanning tree. For every ii from 11 to qq, find and report the number of good vertices.InputThe first line contains two integers nn and qq (3?n?2?1053?n?2?105, 1?q?2?1051?q?2?105)?? the number of nodes and the number of updates, respectively.Each of the next n?1n?1 lines contains two integers uu and vv (1?u,v?n1?u,v?n, u?vu?v)?? vertices connected by an edge in TT. It is guaranteed that this graph is a tree.Each of the next qq lines contains two integers uu and vv (1?u,v?n1?u,v?n, u?vu?v)?? the endpoints of the edge that is added or removed. It is guaranteed that this edge does not belong to TT.OutputFor each update, print one integer kk?? the number of good vertices ww after the corresponding update.ExamplesInputCopy3 21 21 32 33 2OutputCopy23InputCopy6 61 22 31 44 51 62 53 45 26 43 46 5OutputCopy323232NoteThe first sample is depicted in the following figure.  After the first update, GG contains all three possible edges. The result of a DFS is as follows:   Let the starting vertex be 11. We have two choices of ordering the neighbors of 11, either [2,3][2,3] or [3,2][3,2].   If we choose the former, then we reach vertex 22. Regardless of the ordering of its neighbors, the next visited vertex will be 33. Thus, the spanning tree generated by this DFS will contain edges {1,2}{1,2} and {2,3}{2,3}, which does not equal to TT.  If we choose the latter, we obtain a spanning tree with edges {1,3}{1,3} and {2,3}{2,3}.  Hence, there is no way of ordering the neighbors of vertices such that the DFS produces TT, and subsequently 11 is not a good vertex.  Let the starting vertex be 22. We have two choices of traversing its neighbors. If we visit 33 first, then the spanning tree will consist of edges {2,3}{2,3} and {1,3}{1,3}, which is not equal to TT. If we, however, visit 11 first, then we can only continue to 33 from here, and the spanning tree will consist of edges {1,2}{1,2} and {1,3}{1,3}, which equals to TT. Hence, 22 is a good vertex.  The case when we start in the vertex 33 is symmetrical to starting in 22, and hence 33 is a good vertex.  Therefore, the answer is 22.After the second update, the edge between 22 and 33 is removed, and G=TG=T. It follows that the spanning tree generated by DFS will be always equal to TT independent of the choice of the starting vertex. Thus, the answer is 33.In the second sample, the set of good vertices after the corresponding query is:   {2,3,5}{2,3,5}  {3,5}{3,5}  {3,4,5}{3,4,5}  {4,5}{4,5}  {4,5,6}{4,5,6}  {5,6}{5,6} '